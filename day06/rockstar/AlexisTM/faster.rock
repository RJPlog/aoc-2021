Say "Hashtable for 16 iterations"
Rock Hashy with "50027", "61138", "0224", "1335", "2446", "3557", "4668", "507", "618"

(Do 16 iterations at once)
QuickChange wants the array
Rock Quickiter One
While the array ain't nothing
Roll the array into Val
If Hashy at Val is mysterious
Cast Val

Rock Quickiter One with Hashy at Val

Join Quickiter One
Shatter Quickiter One
Give back Quickiter One

Say "Precomputation up to 128"
(Precompute 0, 1, 2, 3, 4, 5, 6, 7, 8 possible values of the number)
the max is 8
Count is 0
Rock the taxes
Rock a reduction

While Count is not as great as the max plus 1
The iteration is nothing
Rock the iteration with 1
Roll the iteration
Roll the iteration
Rock the iteration with Count
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Put QuickChange taking the iteration into the iteration
Rock the taxes with the iteration
Build Count up



Say "Reflection from 128 to 256"
(Reflection for 1-5)
the reflection is 5
Rock Final Hashtable with 42
While the reflection is greater than nothing
The total is 0
Count is 0
Let Size be the taxes at the reflection of 1
Let Array be the taxes at the reflection
While Count is less than Size
Let Val be Array at Count
Cast Val
Let the total be the total with the taxes at Val of 1
Build Count up

Let Final Hashtable at the reflection be the total
Knock the reflection down


Say "Solving input..."
The comma is four four
Cast the comma
Final Result is 0
Listen to the problem
Shatter the problem with the comma
While the problem ain't nothing
Roll the problem into Val
Cast Val
Let Final Result be with Final Hashtable at Val

Say Final Result
